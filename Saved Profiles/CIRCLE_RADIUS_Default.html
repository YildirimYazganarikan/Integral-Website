<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MultiCircle1</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: monospace; transition: background 0.3s, color 0.3s; }
        canvas { position: absolute; top: 0; left: 0; }
        #controls { position: absolute; bottom: 30px; left: 0; width: 100%; display: flex; justify-content: center; gap: 10px; z-index: 10; }
        button { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 8px 16px; border-radius: 20px; cursor: pointer; opacity: 0.5; transition: all 0.3s; text-transform: uppercase; font-size: 12px; letter-spacing: 1px; }
        button:hover { opacity: 0.8; }
        #theme-btn { position: absolute; top: 12px; right: 12px; z-index: 10; opacity: 0.3; font-size: 12px; padding: 4px 8px; border-radius: 12px; background: transparent; border: none; }
        #theme-btn:hover { opacity: 0.6; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <button id="theme-btn">‚òÄÔ∏è</button>
    <div id="controls">
        <button class="mode-btn" data-mode="LISTENING" style="opacity:1">Listening</button>
        <button class="mode-btn" data-mode="SPEAKING">Speaking</button>
        <button class="mode-btn" data-mode="SEARCHING">Searching</button>
    </div>
    <script id="nora-profile-data" type="application/json">{"id":"1770409810885","name":"MultiCircle1","type":"CIRCLE_RADIUS","settings":{"radius":27,"radiusSensitivity":0.5,"displacementSensitivity":1.9,"sizeSensitivity":1,"density":0.5,"thickness":1,"breathingAmount":14,"breathingFrequency":1.9,"particleFade":0,"noiseScale":1}}</script>
    <script>
    const profile = JSON.parse(document.getElementById('nora-profile-data').textContent);
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let mode = 'LISTENING';
    let time = 0;
    let particles = [];
    let intensity = 0;
    let simInput = 0;
    let simOutput = 0;
    let isDark = true;

    function getColors() {
        if (isDark) {
            return {
                primary: 'rgba(255, 255, 255, 0.9)',
                secondary: 'rgba(255, 255, 255, 0.4)',
                accent: '255, 255, 255'
            };
        } else {
            return {
                primary: 'rgba(0, 0, 0, 0.9)',
                secondary: 'rgba(0, 0, 0, 0.4)',
                accent: '0, 0, 0'
            };
        }
    }

    function updateTheme() {
        document.body.style.background = isDark ? '#000' : '#fff';
        document.body.style.color = isDark ? '#fff' : '#000';
        document.querySelectorAll('button').forEach(btn => {
            btn.style.background = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
            btn.style.borderColor = isDark ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.2)';
            btn.style.color = isDark ? 'white' : 'black';
        });
        const themeBtn = document.getElementById('theme-btn');
        if (themeBtn) themeBtn.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
    }

    function init() {
        resize();
        window.addEventListener('resize', resize);
        
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                mode = e.target.dataset.mode;
                document.querySelectorAll('.mode-btn').forEach(b => b.style.opacity = '0.5');
                e.target.style.opacity = '1';
            });
        });

        document.getElementById('theme-btn').addEventListener('click', () => {
            isDark = !isDark;
            updateTheme();
        });

        const settings = profile.settings;
        const width = canvas.width;
        const height = canvas.height;
        const count = Math.floor(50 + settings.density * 250);

        particles = [];
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count;
            particles.push({
                angle, 
                size: Math.random() * 2 + 1,
                opacity: Math.random() * 0.5 + 0.5,
                theta: Math.random() * 2 * Math.PI,
                phi: Math.acos(2 * Math.random() - 1)
            });
        }
        animate();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function drawParticleCircle(w, h, time, intensity, settings, color) {
        const centerX = w / 2;
        const centerY = h / 2;
        const baseRadius = Math.min(w, h) * (settings.radius / 800);
        
        const freq = settings.breathingFrequency || 2;
        const amount = settings.breathingAmount || 5;
        const breathe = Math.sin(time * freq) * amount;
        const radiusExpansion = intensity * 40 * settings.radiusSensitivity;
        const displacementScale = intensity * 20 * settings.displacementSensitivity;

        ctx.fillStyle = color;
        particles.forEach(p => {
            const noise = Math.sin(p.angle * 10 + time * 5) * Math.cos(p.angle * 5 - time * 2);
            
            let spectralDisplacement = 0;
            if (intensity > 0.05) {
                const spike = Math.abs(Math.sin(p.angle * 8 + time * 2));
                spectralDisplacement = spike * intensity * 80 * settings.displacementSensitivity;
            }

            let size = p.size;
            if (intensity > 0.1) size += (intensity * 2 * settings.displacementSensitivity);
            const dynamicR = baseRadius + breathe + radiusExpansion + spectralDisplacement + (noise * displacementScale);
            let x = centerX + Math.cos(p.angle) * dynamicR;
            let y = centerY + Math.sin(p.angle) * dynamicR;
            
            if (mode === 'SEARCHING') {
                const orbitSpeed = time * 4;
                x = centerX + Math.cos(p.angle + orbitSpeed) * (baseRadius + Math.sin(time*5)*10);
                y = centerY + Math.sin(p.angle + orbitSpeed) * (baseRadius + Math.sin(time*5)*10);
            }
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.globalAlpha = p.opacity;
            ctx.fill();
        });
        ctx.globalAlpha = 1;
    }
    
    function drawStraightLine(w, h, time, intensity, settings, color, secColor) {
        ctx.strokeStyle = color;
        ctx.lineWidth = settings.thickness;
        ctx.lineCap = 'round';
        const centerY = h / 2;
        const points = Math.floor(10 + settings.density * 190);
        const spacing = w / points;
        const amplitude = 50 * intensity * settings.displacementSensitivity;

        ctx.beginPath();
        for (let i = 0; i <= points; i++) {
            const x = i * spacing;
            let offset = Math.sin(i * 0.1 + time) * 5;
            if (intensity > 0.001) {
                const edge = Math.sin((i / points) * Math.PI);
                offset += (Math.sin(i * 0.2 + time * 10) + Math.cos(i * 0.5 - time * 8)) * amplitude * edge;
            }
            if (mode === 'SEARCHING') offset = Math.sin(i * 0.2 - time * 10) * 20 * Math.sin((i/points) * Math.PI);
            i === 0 ? ctx.moveTo(x, centerY + offset) : ctx.lineTo(x, centerY + offset);
        }
        ctx.stroke();
    }

    function drawSimpleCircle(w, h, time, intensity, settings, color, secColor, isDark) {
        const centerX = w / 2;
        const centerY = h / 2;
        const baseR = Math.min(w, h) * (settings.radius / 800);
        const freq = settings.breathingFrequency || 1.5;
        const amount = settings.breathingAmount || 5;
        const breathe = Math.sin(time * freq) * amount;
        const r = baseR + breathe + (intensity * 60 * settings.radiusSensitivity);

        if (mode === 'SEARCHING') {
            ctx.beginPath();
            ctx.strokeStyle = secColor;
            ctx.lineWidth = 2;
            ctx.arc(centerX, centerY, baseR + Math.sin(time*10)*5 + 30, time*5, time*5 + Math.PI*1.5);
            ctx.stroke();
        }

        ctx.fillStyle = isDark ? '#000' : '#fff';
        ctx.strokeStyle = color;
        ctx.lineWidth = settings.thickness;
        ctx.beginPath();
        ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        if (intensity > 0.05) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(centerX, centerY, Math.min(r, r * intensity * 0.8 * settings.displacementSensitivity), 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function drawCircleRadius(w, h, time, intensity, settings, accent) {
        const centerX = w / 2;
        const centerY = h / 2;
        const freq = settings.breathingFrequency || 1;
        const amount = settings.breathingAmount || 0;
        const breathe = Math.sin(time * freq) * amount;
        const r = (Math.min(w, h) * (settings.radius / 800) * 3) + (intensity * 100 * settings.radiusSensitivity) + breathe;
        
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(time * 0.05);
        ctx.translate(-centerX, -centerY);
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, Math.max(0,r), 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(' + accent + ', 0.05)';
        ctx.fill();
        
        ctx.lineWidth = settings.thickness;
        for(let i=0; i<5; i++) {
            const chaos = intensity * 20 * settings.displacementSensitivity;
            const ringR = r + (i * 15) + Math.sin(time * (mode === 'SEARCHING' ? 10 : 2) - i) * ((intensity * 100 * settings.radiusSensitivity * 0.2) + chaos);
            ctx.beginPath();
            if (mode === 'SEARCHING') ctx.setLineDash([10, 20]); else ctx.setLineDash([]);
            ctx.arc(centerX, centerY, Math.max(0, ringR), 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(' + accent + ',' + (0.6 * (1 - i/5)) + ')';
            ctx.stroke();
        }
        ctx.restore();
    }

    function drawSphericalParticle(w, h, time, intensity, settings, color, secColor) {
        const centerX = w / 2;
        const centerY = h / 2;
        const baseRadius = Math.min(w, h) * (settings.radius / 800) * 2;
        const rotMult = settings.rotationSpeed !== undefined ? settings.rotationSpeed : 1.0;
        let rotSpeedX = (mode === 'SEARCHING' ? 2.0 : 0.5) * rotMult;
        let rotSpeedY = (mode === 'SEARCHING' ? 3.0 : 0.8) * rotMult;
        
        const freq = settings.breathingFrequency || 2;
        const amount = settings.breathingAmount || 5;
        const breathe = Math.sin(time * freq) * amount;
        
        let currentRadius = baseRadius + (intensity * 50 * settings.radiusSensitivity) + breathe;
        if (mode === 'SEARCHING') {
            currentRadius = baseRadius + Math.sin(time * 3) * 15 + Math.cos(time * 2.3) * 10;
        }
        
        const jitter = intensity * 10 * settings.displacementSensitivity;
        
        ctx.fillStyle = color;
        particles.forEach((p, idx) => {
             const rotX = time * rotSpeedX;
             const rotY = time * rotSpeedY;
             
             let particleR = currentRadius + (Math.random() - 0.5) * jitter;
             if (mode === 'SEARCHING') {
                 particleR += Math.sin(idx * 0.5 + time * 4) * 8;
             }
             
             let x = particleR * Math.sin(p.phi) * Math.cos(p.theta);
             let y = particleR * Math.sin(p.phi) * Math.sin(p.theta);
             let z = particleR * Math.cos(p.phi);
             let x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
             let z1 = z * Math.cos(rotY) + x * Math.sin(rotY);
             let y2 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
             let z2 = z1 * Math.cos(rotX) + y * Math.sin(rotX);
             const scale = 300 / (300 + z2);
             const alpha = Math.max(0.1, Math.min(1, scale * p.opacity));
             
             let particleSize = (p.size * scale) + intensity * 2;
             if (mode === 'SEARCHING') {
                 particleSize = (p.size * scale) * (0.8 + Math.sin(time * 5 + idx) * 0.3);
             }
             
             ctx.globalAlpha = alpha;
             ctx.beginPath();
             ctx.arc(centerX + x1 * scale, centerY + y2 * scale, Math.max(0.5, particleSize), 0, Math.PI * 2);
             ctx.fill();
        });
        ctx.globalAlpha = 1;
    }

    function animate() {
        if (mode === 'LISTENING') {
            if (Math.random() > 0.95) simInput = Math.random();
            simInput *= 0.9;
            simOutput = 0;
        } else if (mode === 'SPEAKING') {
            simInput = 0;
            simOutput = (Math.sin(time * 5) + 1) * 0.5;
        } else {
            simInput = 0;
            simOutput = 0;
        }
        let target = mode === 'LISTENING' ? simInput : (mode === 'SPEAKING' ? simOutput : 0.2);
        intensity += (target - intensity) * 0.1;
        time += 0.02;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const settings = profile.settings;
        const colors = getColors();
        
        if (profile.type === 'PARTICLE_CIRCLE') drawParticleCircle(canvas.width, canvas.height, time, intensity, settings, colors.primary);
        else if (profile.type === 'STRAIGHT_LINE') drawStraightLine(canvas.width, canvas.height, time, intensity, settings, colors.primary, colors.secondary);
        else if (profile.type === 'SIMPLE_CIRCLE') drawSimpleCircle(canvas.width, canvas.height, time, intensity, settings, colors.primary, colors.secondary, isDark);
        else if (profile.type === 'CIRCLE_RADIUS') drawCircleRadius(canvas.width, canvas.height, time, intensity, settings, colors.accent);
        else if (profile.type === 'SPHERICAL_PARTICLE') drawSphericalParticle(canvas.width, canvas.height, time, intensity, settings, colors.primary, colors.secondary);
        
        requestAnimationFrame(animate);
    }
    init();
    </script>
</body>
</html>