<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Line</title>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; transition: background 0.3s, color 0.3s; }
        body.light { background: #fff; color: #000; }
        canvas { position: absolute; top: 0; left: 0; }
        
        /* Top controls container */
        .top-controls { position: absolute; top: 16px; left: 0; right: 0; display: flex; justify-content: center; align-items: center; z-index: 10; gap: 24px; }
        
        /* Mode buttons */
        .mode-buttons { display: flex; gap: 8px; }
        .mode-btn { 
            padding: 6px 12px; 
            font-size: 10px; 
            font-family: inherit;
            font-weight: 400;
            text-transform: uppercase; 
            letter-spacing: 0.1em;
            border-radius: 4px; 
            cursor: pointer; 
            transition: all 0.2s;
            border: none;
        }
        .mode-btn.dark { background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.5); }
        .mode-btn.dark:hover { background: rgba(255,255,255,0.2); }
        .mode-btn.dark.active { background: #fff; color: #000; }
        .mode-btn.light { background: rgba(0,0,0,0.1); color: rgba(0,0,0,0.5); }
        .mode-btn.light:hover { background: rgba(0,0,0,0.15); }
        .mode-btn.light.active { background: #000; color: #fff; }
        
        /* Theme toggle (matching main app) */
        .theme-toggle { 
            display: flex; 
            gap: 2px; 
            padding: 4px;
            border-radius: 8px;
        }
        .theme-toggle.dark { background: rgba(255,255,255,0.1); }
        .theme-toggle.light { background: rgba(0,0,0,0.1); }
        .theme-btn-half {
            width: 28px;
            height: 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 12px;
            background: transparent;
        }
        .theme-btn-half.dark { color: rgba(255,255,255,0.4); }
        .theme-btn-half.dark:hover { color: rgba(255,255,255,0.7); }
        .theme-btn-half.dark.active { background: #fff; color: #000; }
        .theme-btn-half.light { color: rgba(0,0,0,0.4); }
        .theme-btn-half.light:hover { color: rgba(0,0,0,0.7); }
        .theme-btn-half.light.active { background: #000; color: #fff; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <!-- Top controls -->
    <div class="top-controls">
        <div class="mode-buttons">
            <button class="mode-btn dark active" data-mode="LISTENING">L</button>
            <button class="mode-btn dark" data-mode="SPEAKING">S</button>
            <button class="mode-btn dark" data-mode="SEARCHING">S</button>
        </div>
        <div class="theme-toggle dark">
            <button class="theme-btn-half dark" data-theme="light" title="Light mode">☀</button>
            <button class="theme-btn-half dark active" data-theme="dark" title="Dark mode">●</button>
        </div>
    </div>
    
    <script id="nora-profile-data" type="application/json">{"id":"1770410138186","name":"Line","type":"STRAIGHT_LINE","settings":{"radius":100,"radiusSensitivity":1,"displacementSensitivity":0.5,"sizeSensitivity":1,"density":0.65,"thickness":8,"breathingAmount":5,"breathingFrequency":2,"particleFade":0,"noiseScale":1,"listeningRate":7,"listeningIntensity":0.9,"speakingRate":10},"_filename":"Line.html","_isDefault":false}</script>
    <script>
    const profile = JSON.parse(document.getElementById('nora-profile-data').textContent);
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let mode = 'LISTENING';
    let time = 0;
    let particles = [];
    let intensity = 0;
    let simInput = 0;
    let simOutput = 0;
    let isDark = true;

    function getColors() {
        if (isDark) {
            return {
                primary: 'rgba(255, 255, 255, 0.9)',
                secondary: 'rgba(255, 255, 255, 0.4)',
                accent: '255, 255, 255'
            };
        } else {
            return {
                primary: 'rgba(0, 0, 0, 0.9)',
                secondary: 'rgba(0, 0, 0, 0.4)',
                accent: '0, 0, 0'
            };
        }
    }

    function updateTheme() {
        document.body.classList.toggle('light', !isDark);
        
        // Update all buttons with theme class
        document.querySelectorAll('.mode-btn, .theme-btn-half').forEach(btn => {
            btn.classList.remove('dark', 'light');
            btn.classList.add(isDark ? 'dark' : 'light');
        });
        document.querySelectorAll('.theme-toggle').forEach(el => {
            el.classList.remove('dark', 'light');
            el.classList.add(isDark ? 'dark' : 'light');
        });
        
        // Update theme button active states
        document.querySelectorAll('.theme-btn-half').forEach(btn => {
            const isThisTheme = (btn.dataset.theme === 'dark') === isDark;
            btn.classList.toggle('active', isThisTheme);
        });
    }

    function init() {
        resize();
        window.addEventListener('resize', resize);
        
        // Mode button handlers
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                mode = e.target.dataset.mode;
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
            });
        });

        // Theme toggle handlers
        document.querySelectorAll('.theme-btn-half').forEach(btn => {
            btn.addEventListener('click', () => {
                isDark = btn.dataset.theme === 'dark';
                updateTheme();
            });
        });

        const settings = profile.settings;
        const width = canvas.width;
        const height = canvas.height;
        const count = Math.floor(50 + settings.density * 250);

        particles = [];
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count;
            particles.push({
                angle, 
                size: Math.random() * 2 + 1,
                opacity: Math.random() * 0.5 + 0.5,
                theta: Math.random() * 2 * Math.PI,
                phi: Math.acos(2 * Math.random() - 1)
            });
        }
        animate();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function drawParticleCircle(w, h, time, intensity, settings, color) {
        const centerX = w / 2;
        const centerY = h / 2;
        const baseRadius = Math.min(w, h) * (settings.radius / 800);
        
        const freq = settings.breathingFrequency || 2;
        const amount = settings.breathingAmount || 5;
        const breathe = Math.sin(time * freq) * amount;
        const radiusExpansion = intensity * 40 * settings.radiusSensitivity;
        const displacementScale = intensity * 20 * settings.displacementSensitivity;

        ctx.fillStyle = color;
        particles.forEach(p => {
            const noise = Math.sin(p.angle * 10 + time * 5) * Math.cos(p.angle * 5 - time * 2);
            
            let spectralDisplacement = 0;
            if (intensity > 0.05) {
                const spike = Math.abs(Math.sin(p.angle * 8 + time * 2));
                spectralDisplacement = spike * intensity * 80 * settings.displacementSensitivity;
            }

            let size = p.size;
            if (intensity > 0.1) size += (intensity * 2 * settings.displacementSensitivity);
            const dynamicR = baseRadius + breathe + radiusExpansion + spectralDisplacement + (noise * displacementScale);
            let x = centerX + Math.cos(p.angle) * dynamicR;
            let y = centerY + Math.sin(p.angle) * dynamicR;
            
            if (mode === 'SEARCHING') {
                const orbitSpeed = time * 4;
                x = centerX + Math.cos(p.angle + orbitSpeed) * (baseRadius + Math.sin(time*5)*10);
                y = centerY + Math.sin(p.angle + orbitSpeed) * (baseRadius + Math.sin(time*5)*10);
            }
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.globalAlpha = p.opacity;
            ctx.fill();
        });
        ctx.globalAlpha = 1;
    }
    
    function drawStraightLine(w, h, time, intensity, settings, color, secColor) {
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        const centerY = h / 2;
        const points = Math.floor(10 + settings.density * 190);
        const spacing = w / points;
        const amplitude = 50 * intensity * settings.displacementSensitivity;

        // === USER LINE (GRAY/LIGHTER) - Active in LISTENING mode ===
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = settings.thickness;
        
        for (let i = 0; i <= points; i++) {
            const x = i * spacing;
            let offset = Math.sin(i * 0.1 + time) * 3;
            
            if (mode === 'LISTENING' && intensity > 0.001) {
                const edgeFactor = Math.sin((i / points) * Math.PI);
                const wave1 = Math.sin(i * 0.2 + time * 10);
                const wave2 = Math.cos(i * 0.5 - time * 8);
                offset += (wave1 + wave2) * amplitude * edgeFactor;
            }
            
            if (mode === 'SEARCHING') {
                offset = Math.sin(i * 0.2 - time * 10) * 15 * Math.sin((i / points) * Math.PI);
            }
            
            i === 0 ? ctx.moveTo(x, centerY + offset) : ctx.lineTo(x, centerY + offset);
        }
        ctx.stroke();

        // === AI LINE (DARKER) - Active in SPEAKING mode ===
        ctx.beginPath();
        ctx.strokeStyle = secColor;
        ctx.lineWidth = settings.thickness * 0.8;
        
        const aiAmplitude = mode === 'SPEAKING' ? 40 * settings.displacementSensitivity : 5;
        const aiSpeed = mode === 'SPEAKING' ? 12 : 2;
        
        for (let i = 0; i <= points; i++) {
            const x = i * spacing;
            const edgeFactor = Math.sin((i / points) * Math.PI);
            const wave1 = Math.sin(i * 0.15 + time * aiSpeed);
            const wave2 = Math.cos(i * 0.4 - time * aiSpeed * 0.8);
            let offset = (wave1 + wave2) * aiAmplitude * edgeFactor * -1;
            
            if (mode === 'SEARCHING') {
                offset = Math.cos(i * 0.2 + time * 8) * 10 * edgeFactor;
            }
            
            i === 0 ? ctx.moveTo(x, centerY + offset) : ctx.lineTo(x, centerY + offset);
        }
        ctx.stroke();
    }

    function drawSimpleCircle(w, h, time, intensity, settings, color, secColor, isDark) {
        const centerX = w / 2;
        const centerY = h / 2;
        const baseR = Math.min(w, h) * (settings.radius / 800);
        const freq = settings.breathingFrequency || 1.5;
        const amount = settings.breathingAmount || 5;
        const breathe = Math.sin(time * freq) * amount;
        const r = baseR + breathe + (intensity * 60 * settings.radiusSensitivity);

        if (mode === 'SEARCHING') {
            ctx.beginPath();
            ctx.strokeStyle = secColor;
            ctx.lineWidth = 2;
            ctx.arc(centerX, centerY, baseR + Math.sin(time*10)*5 + 30, time*5, time*5 + Math.PI*1.5);
            ctx.stroke();
        }

        ctx.fillStyle = isDark ? '#000' : '#fff';
        ctx.strokeStyle = color;
        ctx.lineWidth = settings.thickness;
        ctx.beginPath();
        ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        if (intensity > 0.05) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(centerX, centerY, Math.min(r, r * intensity * 0.8 * settings.displacementSensitivity), 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function drawCircleRadius(w, h, time, intensity, settings, accent) {
        const centerX = w / 2;
        const centerY = h / 2;
        const freq = settings.breathingFrequency || 1;
        const amount = settings.breathingAmount || 0;
        const breathe = Math.sin(time * freq) * amount;
        const r = (Math.min(w, h) * (settings.radius / 800) * 3) + (intensity * 100 * settings.radiusSensitivity) + breathe;
        
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(time * 0.05);
        ctx.translate(-centerX, -centerY);
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, Math.max(0,r), 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(' + accent + ', 0.05)';
        ctx.fill();
        
        ctx.lineWidth = settings.thickness;
        for(let i=0; i<5; i++) {
            const chaos = intensity * 20 * settings.displacementSensitivity;
            const ringR = r + (i * 15) + Math.sin(time * (mode === 'SEARCHING' ? 10 : 2) - i) * ((intensity * 100 * settings.radiusSensitivity * 0.2) + chaos);
            ctx.beginPath();
            if (mode === 'SEARCHING') ctx.setLineDash([10, 20]); else ctx.setLineDash([]);
            ctx.arc(centerX, centerY, Math.max(0, ringR), 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(' + accent + ',' + (0.6 * (1 - i/5)) + ')';
            ctx.stroke();
        }
        ctx.restore();
    }

    function drawSphericalParticle(w, h, time, intensity, settings, color, secColor) {
        const centerX = w / 2;
        const centerY = h / 2;
        const baseRadius = settings.radius ?? 160; // Use settings.radius directly like main app
        const rotMult = settings.rotationSpeed !== undefined ? settings.rotationSpeed : 1.0;
        let rotSpeedX = (mode === 'SEARCHING' ? 2.0 : 0.5) * rotMult;
        let rotSpeedY = (mode === 'SEARCHING' ? 3.0 : 0.8) * rotMult;
        
        const freq = settings.breathingFrequency || 2;
        const amount = settings.breathingAmount || 5;
        const breathe = Math.sin(time * freq) * amount;
        
        let currentRadius = baseRadius + (intensity * 40) + breathe;
        if (mode === 'SEARCHING') {
            currentRadius = baseRadius + Math.sin(time * 3) * 15 + Math.cos(time * 2.3) * 10;
        }
        
        const jitter = intensity * 10 * settings.displacementSensitivity;
        
        ctx.fillStyle = color;
        particles.forEach((p, idx) => {
             const rotX = time * rotSpeedX;
             const rotY = time * rotSpeedY;
             
             let particleR = currentRadius + (Math.random() - 0.5) * jitter;
             if (mode === 'SEARCHING') {
                 particleR += Math.sin(idx * 0.5 + time * 4) * 8;
             }
             
             let x = particleR * Math.sin(p.phi) * Math.cos(p.theta);
             let y = particleR * Math.sin(p.phi) * Math.sin(p.theta);
             let z = particleR * Math.cos(p.phi);
             let x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
             let z1 = z * Math.cos(rotY) + x * Math.sin(rotY);
             let y2 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
             let z2 = z1 * Math.cos(rotX) + y * Math.sin(rotX);
             const scale = 300 / (300 + z2);
             const alpha = Math.max(0.1, Math.min(1, scale * p.opacity));
             
             let particleSize = (p.size * scale) + intensity * 2;
             if (mode === 'SEARCHING') {
                 particleSize = (p.size * scale) * (0.8 + Math.sin(time * 5 + idx) * 0.3);
             }
             
             ctx.globalAlpha = alpha;
             ctx.beginPath();
             ctx.arc(centerX + x1 * scale, centerY + y2 * scale, Math.max(0.5, particleSize), 0, Math.PI * 2);
             ctx.fill();
         });
        ctx.globalAlpha = 1;
        
        // === OUTER SPHERE (SEARCHING MODE ONLY) ===
        const enableOuterSphere = settings.enableOuterSphere ?? 0;
        if (enableOuterSphere > 0.5 && mode === 'SEARCHING') {
            const outerRadius = settings.outerSphereRadius ?? 300;
            const outerSpeed = settings.outerSphereSpeed ?? 8;
            const outerDensity = settings.outerSphereDensity ?? 0.2;
            const outerColor = isDark ? (settings.outerSphereColorDark ?? '#ff6464') : (settings.outerSphereColorLight ?? '#cc4444');
            
            ctx.fillStyle = outerColor;
            const outerCount = Math.floor(50 * outerDensity);
            
            for (let i = 0; i < outerCount; i++) {
                const phi = Math.acos(2 * (i / outerCount) - 1);
                const theta = 2 * Math.PI * i * 0.618033;
                
                const r = outerRadius + Math.sin(time * outerSpeed * 0.5 + i) * 10;
                
                let x = r * Math.sin(phi) * Math.cos(theta);
                let y = r * Math.sin(phi) * Math.sin(theta);
                let z = r * Math.cos(phi);
                
                const rotX = time * rotSpeedX * 0.5;
                const rotY = time * rotSpeedY * 0.5;
                
                let x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
                let z1 = z * Math.cos(rotY) + x * Math.sin(rotY);
                let y2 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
                let z2 = z1 * Math.cos(rotX) + y * Math.sin(rotX);
                
                const scale = 400 / (400 + z2);
                ctx.globalAlpha = Math.max(0.1, scale * 0.5);
                ctx.beginPath();
                ctx.arc(centerX + x1 * scale, centerY + y2 * scale, Math.max(1, 2 * scale), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
    }

    function animate() {
        if (mode === 'LISTENING') {
            // More active simulation for user voice - oscillating pattern
            simInput = (Math.sin(time * 8) + 1) * 0.25 + (Math.sin(time * 13) + 1) * 0.15;
            if (Math.random() > 0.7) simInput += Math.random() * 0.3;
            simOutput = 0;
        } else if (mode === 'SPEAKING') {
            simInput = 0;
            simOutput = (Math.sin(time * 5) + 1) * 0.5;
        } else {
            simInput = 0;
            simOutput = 0;
        }
        let target = mode === 'LISTENING' ? simInput : (mode === 'SPEAKING' ? simOutput : 0.2);
        intensity += (target - intensity) * 0.15;
        time += 0.02;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const settings = profile.settings;
        const colors = getColors();
        
        if (profile.type === 'PARTICLE_CIRCLE') drawParticleCircle(canvas.width, canvas.height, time, intensity, settings, colors.primary);
        else if (profile.type === 'STRAIGHT_LINE') drawStraightLine(canvas.width, canvas.height, time, intensity, settings, colors.primary, colors.secondary);
        else if (profile.type === 'SIMPLE_CIRCLE') drawSimpleCircle(canvas.width, canvas.height, time, intensity, settings, colors.primary, colors.secondary, isDark);
        else if (profile.type === 'CIRCLE_RADIUS') drawCircleRadius(canvas.width, canvas.height, time, intensity, settings, colors.accent);
        else if (profile.type === 'SPHERICAL_PARTICLE') drawSphericalParticle(canvas.width, canvas.height, time, intensity, settings, colors.primary, colors.secondary);
        
        requestAnimationFrame(animate);
    }
    init();
    </script>
</body>
</html>